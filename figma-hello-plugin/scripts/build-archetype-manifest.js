#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const rootDir = path.resolve(__dirname, '../../admin/specs/ui-archetypes');
const outputPath = path.resolve(__dirname, '../src/lib/archetype-manifest.ts');

function titleCase(str) {
  return str
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function readSections(pageName, sectionsDir) {
  if (!fs.existsSync(sectionsDir)) return [];
  const files = fs
    .readdirSync(sectionsDir)
    .filter((file) => file.endsWith('.json'))
    .sort();

  return files.map((file) => {
    const filePath = path.join(sectionsDir, file);
    const raw = fs.readFileSync(filePath, 'utf8');
    let parsed;
    try {
      parsed = JSON.parse(raw);
    } catch (error) {
      throw new Error(`JSON 파싱 실패: ${filePath} — ${error.message}`);
    }

    const order = typeof parsed?.meta?.order === 'number' ? parsed.meta.order : null;
    const sectionId = parsed?.meta?.section || file.replace(/\.json$/, '');
    const label = titleCase(sectionId);

    const designSurface = parsed?.meta?.designSurface || 'admin';
    const designSurfaceLabel =
      parsed?.meta?.designSurfaceLabel || titleCase(designSurface.replace(/[-_]/g, ' '));
    const route = parsed?.meta?.route || `/admin/${pageName}`;
    const routeLabel = parsed?.meta?.routeLabel || titleCase(pageName);
    const slot = parsed?.meta?.slot || 'main';
    const slotLabel = parsed?.meta?.slotLabel || titleCase(slot.replace(/[-_]/g, ' '));

    return {
      id: `${pageName}/sections/${file}`,
      order,
      label,
      description: parsed?.meta?.description || '',
      raw,
      designSurface,
      designSurfaceLabel,
      route,
      routeLabel,
      slot,
      slotLabel,
    };
  });
}

function buildManifest() {
  if (!fs.existsSync(rootDir)) {
    throw new Error(`아키타입 디렉터리를 찾을 수 없습니다: ${rootDir}`);
  }

  const pages = fs
    .readdirSync(rootDir)
    .filter((name) => fs.statSync(path.join(rootDir, name)).isDirectory())
    .sort();

  const manifest = {
    generatedAt: new Date().toISOString(),
    surfaces: {},
    routes: {},
    pages: {},
  };

  for (const page of pages) {
    const sectionsDir = path.join(rootDir, page, 'sections');
    const sections = readSections(page, sectionsDir);
    manifest.pages[page] = {
      label: titleCase(page),
      sections: sections.map(
        ({ designSurface, designSurfaceLabel, route, routeLabel, slot, slotLabel, ...rest }) =>
          rest,
      ),
    };

    sections.forEach((section) => {
      const { designSurface, designSurfaceLabel, route, routeLabel, slot, slotLabel, ...rest } =
        section;

      if (!manifest.surfaces[designSurface]) {
        manifest.surfaces[designSurface] = {
          label: designSurfaceLabel,
          routes: {},
        };
      }

      if (!manifest.surfaces[designSurface].routes[route]) {
        manifest.surfaces[designSurface].routes[route] = {
          label: routeLabel,
          slots: {},
        };
      }

      if (!manifest.surfaces[designSurface].routes[route].slots[slot]) {
        manifest.surfaces[designSurface].routes[route].slots[slot] = {
          label: slotLabel,
          sections: [],
        };
      }

      manifest.surfaces[designSurface].routes[route].slots[slot].sections.push(rest);

      if (!manifest.routes[route]) {
        manifest.routes[route] = {
          label: routeLabel,
          slots: {},
        };
      }
      if (!manifest.routes[route].slots[slot]) {
        manifest.routes[route].slots[slot] = {
          label: slotLabel,
          sections: [],
        };
      }
      manifest.routes[route].slots[slot].sections.push(rest);
    });
  }

  Object.values(manifest.routes).forEach((route) => {
    Object.values(route.slots).forEach((slot) => {
      slot.sections.sort((a, b) => {
        if (a.order === null && b.order === null) return 0;
        if (a.order === null) return 1;
        if (b.order === null) return -1;
        return a.order - b.order;
      });
    });
  });

  Object.values(manifest.surfaces).forEach((surface) => {
    Object.values(surface.routes).forEach((route) => {
      Object.values(route.slots).forEach((slot) => {
        slot.sections.sort((a, b) => {
          if (a.order === null && b.order === null) return 0;
          if (a.order === null) return 1;
          if (b.order === null) return -1;
          return a.order - b.order;
        });
      });
    });
  });

  return manifest;
}

function emit(manifest) {
  const header = `/* eslint-disable */\n// This file is auto-generated by scripts/build-archetype-manifest.js\n// Do not edit manually.\n`;
  const content = `${header}\nexport interface ArchetypeSection {\n  id: string;\n  order: number | null;\n  label: string;\n  description: string;\n  raw: string;\n}\n\nexport interface ArchetypeSlot {\n  label: string;\n  sections: ArchetypeSection[];\n}\n\nexport interface ArchetypeRoute {\n  label: string;\n  slots: Record<string, ArchetypeSlot>;\n}\n\nexport interface ArchetypePage {\n  label: string;\n  sections: ArchetypeSection[];\n}\n\nexport interface ArchetypeSurface {\n  label: string;\n  routes: Record<string, ArchetypeRoute>;\n}\n\nexport interface ArchetypeManifest {\n  generatedAt: string;\n  surfaces: Record<string, ArchetypeSurface>;\n  routes: Record<string, ArchetypeRoute>;\n  pages: Record<string, ArchetypePage>;\n}\n\nexport const archetypeManifest: ArchetypeManifest = ${JSON.stringify(
    manifest,
    null,
    2,
  )};\n`;

  fs.writeFileSync(outputPath, content, 'utf8');
}

try {
  const manifest = buildManifest();
  emit(manifest);
  console.log(`[build-archetype-manifest] Generated manifest at ${outputPath}`);
} catch (error) {
  console.error('[build-archetype-manifest] Error:', error.message);
  process.exit(1);
}
